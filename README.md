# SoftwareDevelopment

## Интерпретатор CLI

### Команда

- Илья Иванцов
- Доморацкий Эридан

### Задание 1: Архитектура

На верхнем уровне приложение состоит из двух модулей:

```
      ||
     Text
      ||
      \/
  +--------+
  | Parser | <-- State
  +--------+
      ||           ||
    Command       Text
      ||           ||
      \/           \/
  +------------------------+
  |         Runner         | <-> State
  +------------------------+
              ||
             Text
              ||
              \/
```

Входящий поток текста направляется в парсер и раннер.

Снаружи всё это управляется циклом, в котором парсер разбирает вводимые команды и преобразует их
в объекты команд. Объекты команд направляются в раннер, который запускает команды, направляя в них
поток ввода текста и предоставляя работу с состоянием (чтение и запись). На выходе из раннера
получается выходной поток, порождаемый выполняемыми командами или обработкой ошибок их выполнения.

#### State

Состояние состоит из двух частей:

- Переменные окружения -- это словарь, содержащий в себе существующие переменные окружения и их
значения

- Флаг работы -- булев флаг, определяющий, продолжается ли работа приложения

Объект состояния предоставляет доступ на чтение и запись переменных окружения, на чтение флага
работы и на установку флага работы в ложное значение (завершение работы).

#### Command

Объект команды выставляет в качестве интерфейса один метод, принимающий на вход потоки ввода и
вывода, а также изменяемый объект состояния приложения. Пайплайн также является командой,
состоящей из нескольких команд.

#### Parser

Парсер принимает на вход поток ввода и считывает его первую строку, затем разбирает её на команду
и возвращает объект команды или выбрасывает исключение. Важно, что для считывания строки нужен
буферизующий поток ввода, чтобы была возможность отдать ненужные символы следующему этапу
обработки.

Подстановка переменных осуществляется именно на этом шаге, чтобы иметь возможность продолжить
разбор команды после подстановки. Для этого парсеру предоставляется доступ к текущему состоянию
программы, чтобы использовать переменные окружения из неё.

Парсер имеет единственный метод, принимающий буферизированный поток тектового ввода и возвращающий
объект команды, либо выбрасывающий исключение.

#### Runner

Раннер -- это менеджер запуска команд. Сам по себе он необходим только для запуска команд.
Любые возникающие в процессе работы команды исключения выбрасываются наружу.

#### Жизненный цикл

При старте программы запускается цикл, итерирующийся пока флаг работы из состояния установлен в
истинное значение. В цикле последовательно запускается парсер и, если не было ошибки при парсинге,
передаёт результат в раннер.

При возникновении ошибок парсинга или выполнения команд они перехватываются и обрабатываются
здесь же. Данный <<верхний>> уровень программы не выделяется в отдельный модуль и остаётся
не названным, он отвечает за вывод приглашения на ввод, обработку ошибок и передачу управления
остальным модулям.

#### Алгоритм парсинга

На входе алгоритма парсинга строка команды и переменные окружения.
Сам алгоритм следующий:

- На верхнем уровне строка обрабатывается слева направо посимвольно для выделения строк, обёрнутых
в одинарные и двойные кавычки, разделения строки по пробельным символам (находящимися вне кавычек,
регулярное выражение `\s+`), а также для разделения пайплайна на простые команды

- Для всех подстрок, в которых возможна подстановка переменных (вне кавычек и в двойных кавычках),
запускается специальная функция, которая подставляет переменные из окружения

- Функция подстановки переменных принимает на вход строку и переменные окружения и выделяет все
подстроки, подходящие под регулярное выражение `\$([a-zA-Z_]\w*)`. В группе (в скобках в РВ)
оказывается название переменной, значение которой необходимо подставить вместо переменной.
В случае, если переменной не существует в окружении, вместо неё подставляется пустая строка.
Строка с подставленными переменными возвращается как результат работы функции

- Все подстроки исходной строки, переданные в функцию подстановки переменных, заменяются на
результат подстановки. Затем все подстроки, не разделённые пробельными символами, склеиваются
(с удалением символов кавычек) для получения списка аргументов и названия команды (при этом для
каждой команды в пайплайне формируется отдельный список)

- На последнем шаге из каждой команды в пайплайне формируется объект команды по такой логике:

  - Если название команды подходит под регулярное выражение `([a-zA-Z_]\w*)=.*`, то формируется
  команда на установку значения переменной (команда присваивания)

  - Иначе команда выбирается из предопределённого отображения (map, ассоциативный массив) названий
  команд в конструктор. Предполагается, что конструктор -- это функция, принимающая список
  аргументов

  - Если в отображении нет соответствия для данной команды, формируется объект команды, отвечающий
  за выполнение реальной программы на компьютере пользователя

- Все сформированные команды, если их больше одной в пайплайне, оборачиваются в специальную
составную команду пайплайна

- Полученная команда возвращается в качестве результата работы алгоритма

#### Объекты команд

В системе определены три специальные команды:

- Присваивание -- команда, отвечающая за присваивание нового значения переменной окружения

- Пайплайн -- составная команда, управляющая выполнением пайплайна из нескольких команд

- Системная команда -- выполняет команду пытаясь запустить существующий исполняемый файл на
компьютере пользователя

Несколько встроенных команд:

- `cat [FILE]` -- выводит содержимое файла на экран

- `echo [TEXT...]` -- выводит свои аргументы через пробел на экран

- `wc [FILE]` -- подсчитывает число строк, слов и байт в файле

- `pwd` -- выводит текущую рабочую директорию (значение переменной окружения `PWD`)

- `cd` -- изменяет текущую рабочую директорию (значение переменной окружения `PWD`)

- `exit` -- завершает работу программы (устанавливает значение флага работы в состоянии на ложное)

#### Обработка ошибок

При обработке ошибок выводится сообщение с описанием ошибки, понятное человеку, и выполнение
продолжается с приглашения ко вводу новой команды

### Задание 2: Реализация, часть 1

#### Требования

Для работы и сборки приложения необходима установленная JRE не ниже версии 8.

#### Сборка

Выполните команду в корне проекта:

- Для Unix-like систем:
```bash
./mvnw clean package
```

- Для Windows:
```batch
mvnw clean package
```

При этом будет скачан Apache Maven и зависимости проекта.
Затем проект будет собран и запущены тесты, запускаемый файл будет размещён в директории `target`
под названием `shellin-{version}-jar-with-dependencies.jar`.

#### Запуск

Для запуска необходимо в любой директории выполнить команду:
```bash
java -jar <путь до>/shellin-{version}-jar-with-dependencies.jar
```

Например, если вы сейчас в корневой директории проекта и запускаете версию `1.0-SNAPSHOT`,
то команда запуска будет такой:
```bash
java -jar target/shellin-1.0-SNAPSHOT-jar-with-dependencies.jar
```

### Задание 4. Grep

#### Выбор библиотеки для разбора аргументов командной строки

Найденные варианты:

- [kotlin-argparser](https://github.com/xenomachina/kotlin-argparser)
- [Apache Commons CLI](https://commons.apache.org/proper/commons-cli/usage.html)
- [Argparse4j](https://argparse4j.github.io/)
- [arguments-parser](https://github.com/silentsoft/arguments-parser)

Первая библиотека рассчитана на Kotlin, остальные на Java. Других Kotlin-специфичных библиотек найти не получилось.

##### kotlin-argparser

Библиотека предоставляет удобный Kotlin-специфичный API, продемонстрированный в README.
При поиске вариантов библиотек для Kotlin не было найдено никакой другой библиотеки, кроме этой.
Причём, было очень много статей про именно эту библиотеку.
470 звёзд на GitHub на момент анализа.

Из минусов: давно обновлялась, последний коммит от 2020 года.

##### Apache Commons CLI

Популярная библиотека для разбора аргументов на Java. Удобный API, но рассчитанный на Java, а не на Kotlin.
Регулярно обновляется, тысячи использований: в [Maven](https://mvnrepository.com/artifact/commons-cli/commons-cli).

##### Argparse4j

Последняя версия 0.9.0, так и не вышла в релиз.

##### arguments-parser

Судя по README, предоставляется только самый базовый API. Не больше, чем кустарная поделка.
Хотя и недавно обновлялась. Всего две звезды на GitHub. Нет информации об использованиях в Maven.

##### Итог

Серьёзных варианта только два: kotlin-argparser и Apache Commons CLI. Но, учитывая (возможно, кажущуюся) популярность
и удобство предоставляемого API, выбор пал на kotlin-argparser.
